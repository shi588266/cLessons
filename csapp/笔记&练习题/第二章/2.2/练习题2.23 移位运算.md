### 练习题2.23考虑下面的C函数：
int fun1(unsigned word) {
    return (int)((word << 24) >> 24);
}
int fun2(unsigned word) {
    return ((int) word << 24) >> 24;
}

    假设在一个采用补码运算的32位字长的机器上执行这些函数。还假设有符号数值的右移是算术右移，而无符号数值的右移是逻辑右移。A.填写下表，说明这些函数对几个示例参数的结果。你会发现用十六进制表示来做会更方便，只要记住十六进制数字8到F的最高有效位等于 1。

```
"w" "w_bin_bu"   "fun1(w)"   "fun2(w)"
"0x00000076"    "0000 0000 0000 0000 0000 0000 0111 0110"   "118"    "118"
"0x87654321"    "1111 1000 1001 1010 1011 1100 1101 1111"    "33"    "33"
"0x000000c9"    "0000 0000 0000 0000 0000 0000 1100 1001"   "201"    "201"
"0xedcba987"    "1110 1101 1100 1011 1010 1001 1000 0111"   "135"    "-121"
```

`0x00000076` 位向量为:`0000 0000 0000 0000 0000 0000 0111 0110`
word << 24 = `0000 0000 0111 0110 0000 0000 0000 0000` 结果仍为无符号数
逻辑右移((word << 24) >> 24) = `0000 0000 0000 0000 0000 0000 0111 0110`
return (int)((word << 24) >> 24) = `0000 0000 0000 0000 0000 0000 0111 0110` = 118;

`0x00000076` 位向量为:`0000 0000 0000 0000 0000 0000 0111 0110`
强制转换为有符号数位向量(int)word = `0000 0000 0000 0000 0000 0000 0111 0110`
(int)word << 24 = `0000 0000 0111 0110 0000 0000 0000 0000` 结果仍当作有符号数
算术右移((int)word << 24) >> 24 = `0000 0000 0000 0000 0000 0000 0111 0110` =118


`0x87654321`  位向量为:`1000 0111 0110 0101 0100 0011 0010 0001` 
word << 24 = `0010 0001 0000 0000 0000 0000 0000 0000` 结果仍为无符号数
逻辑右移((word << 24) >> 24) = `0000 0000 0000 0000 0000 0000 0010 0001`
return (int)((word << 24) >> 24) = `0000 0000 0000 0000 0000 0000 0010 0001` = 33;

`0x87654321` , 位向量为:`1000 0111 0110 0101 0100 0011 0010 0001`
强制转换为有符号数位向量(int)word = `1000 0111 0110 0101 0100 0011 0010 0001`
(int)word << 24 = `0010 0001 0000 0000 0000 0000 0000 0000` 结果仍当作有符号数
算术右移((int)word << 24) >> 24 = `0000 0000 0000 0000 0000 0011 0010 0001` = 33


`0x000000c9` 位向量为: `0000 0000 0000 0000 0000 0000 1100 1001`
word << 24 = `1100 1001 0000 0000 0000 0000 0000 0000` 结果仍为无符号数
逻辑右移((word << 24) >> 24) = `0000 0000 0000 0000 0000 0000 1100 1001`
return (int)((word << 24) >> 24) = `0000 0000 0000 0000 0000 0000 1100 1001` = 201;

`0x000000c9` 位向量为: `0000 0000 0000 0000 0000 0000 1100 1001`
强制转换为有符号数位向量(int)word = `0000 0000 0000 0000 0000 0000 1100 1001`
(int)word << 24 = `1100 1001 0000 0000 0000 0000 0000 0000` 结果当作有符号数
算术右移((int)word << 24) >> 24 = `0000 0000 0000 0000 0000 0000 1100 1001` = 201


`0xedcba987` 位向量为: `1110 1101 1100 1011 1010 1001 1000 0111`
word << 24 = `1000 0111 0000 0000 0000 0000 0000 0000` 结果仍为无符号数
逻辑右移((word << 24) >> 24) = `0000 0000 0000 0000 0000 0000 1000 0111`
return (int)((word << 24) >> 24) = `0000 0000 0000 0000 0000 0000 1000 0111` = 135;

`0xedcba987` 位向量为: `1110 1101 1100 1011 1010 1001 1000 0111`
强制转换为有符号数位向量(int)word = `1110 1101 1100 1011 1010 1001 1000 0111`
(int)word << 24 = `1000 0111 0000 0000 0000 0000 0000 0000` 结果当作有符号数
算术右移((int)word << 24) >> 24 = `1111 1111 1111 1111 1111 1111 1000 0111` = -121